struct(TestStru3)
{
	count : int32;
	ptest2 : TestStru2[12];
};

@ga : int = 123;
@gb : int[3] = [3,5,1];
@gc : int = 456;
@gd : string = "this is a test";

hook(CompileTest)
{
	onenter{
		$a : int = 12;
		$b : int = 13 * 17;
		$d : int = ptrget(addr($a), 4);
		$e : int[4] = [1,$a,3,$b];
		$c : int;
		$e[1] = $d + $e[2] * $c;
		if ($a==12) {
			$c = $a * $b;
		};
		while($c!=0){
			$c = $c - 1;
		};
		loopi($c,0,3,1){
			$d = $d + 1;
		};
		loopd($c,8,0,-2){
			$d = $d + 1;
			break;
		};
		if($a == 12){
			$d = $d + 1;
		}
		else{
			$d = $d - 1;
		};
		$c = addr($e) + argv(0);
		$d = $c < 1 ? 2 : 3;
		$e[0] = $d ?? 1;
		$f : int32 = struct($d, ptr(ptr(TestStru3.ptest2).ptest).size);
		$g : int64 = dumpcascadeptr(addr($e), 0x08, 0x08);
		return 0;
	};
};

hook(Test1)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("dbg a:%d b:%f c:%s\n",$a,$b,$c);
		dumpcascadeptr(argv(3),0);
		if($a==123){
			ptrset(argv(0),4,1);
		}
		else{ 
			ptrset(argv(0),4,0);
		};
		$i:int = 0;
		loop($i,0,10){
			printf("+%d\n",$i);
		};
		$j:float = $i;
		while($j>0){
			printf("-%f\n",$j);
			//$j=$j-1;
			dec($j,2.0);
		};
		printf(">>> %f\n", $j);
		printf(">>> %f\n", inc($j));
		printf(">>> %f\n", inc($j, 2.0));
		printf(">>> %f\n", inc($j, 3.0));
		printf("%d %d %d\n", stkix(), hookid(), hookver());
		printf("str contains %d %d\n", stringcontains("test","es","te"), stringnotcontains("test","es","fg"));
		printf("str contains any %d %d\n", stringcontainsany("test","es","te"), stringnotcontainsany("test","es","fg"));
		printf("str find %d %d\n", stringfind("test","es"), stringrfind("test","es"));
		printf("str find2 %d %d\n", stringfind("test","es",1), stringrfind("test","es",0));
		return 1;
	};
	onexit{
		printf("dbg time:%d\n",time());
		ptrset(argv(0),4,2);
	};
};

hook(TestMacro1)
{
	onenter{
		$a:int = ptrget(argv(1),4);
		$b:int = ptrget(argv(2),8);
		$c:int = ptrget(argv(3),8);
		printf("dbg a:%d b:%f c:%s\n",$a,$b,$c);
		ptrset(argv(0), 4, $a==1234 ? 1 : (0 ?? 2));
		return 1;
	};
	onexit{
		printf("dbg time:%d\n",time());
		ptrset(argv(0),4,2);
	};
};

hook("CommandBuffer::BeginRenderPass")
{
	onenter{
		printf("CommandBuffer::BeginRenderPass enter time:%d\n",time());
		//dumpstack("CommandBuffer::BeginRenderPass");
		return 0;
	};
	onexit{
		printf("CommandBuffer::BeginRenderPass exit time:%d\n",time());
	};
};
hook("CommandBuffer::EndRenderPass")
{
	onenter{
		printf("CommandBuffer::EndRenderPass enter time:%d\n",time());
		//dumpstack("CommandBuffer::EndRenderPass");
		return 0;
	};
	onexit{
		printf("CommandBuffer::EndRenderPass exit time:%d\n",time());
	};
};
hook("CommandBuffer::Begin")
{
	onenter{
		printf("CommandBuffer::Begin enter time:%d\n",time());
		//dumpstack("CommandBuffer::Begin");
		return 0;
	};
	onexit{
		printf("CommandBuffer::Begin exit time:%d\n",time());
	};
};
hook("CommandBuffer::End")
{
	onenter{
		printf("CommandBuffer::End enter time:%d\n",time());
		//dumpstack("CommandBuffer::End");
		return 0;
	};
	onexit{
		printf("CommandBuffer::End exit time:%d\n",time());
	};
};
hook("TaskExecutor::HandleCommandStream")
{
	onenter{
		printf("TaskExecutor::HandleCommandStream enter time:%d\n",time());
		//dumpstack("TaskExecutor::HandleCommandStream");
		return 0;
	};
	onexit{
		printf("TaskExecutor::HandleCommandStream exit time:%d\n",time());
	};
};
hook("ScratchBuffer::ClearPool")
{
	onenter{
		printf("ScratchBuffer::ClearPool enter time:%d\n",time());
		//dumpstack("ScratchBuffer::ClearPool");
		return 0;
	};
	onexit{
		printf("ScratchBuffer::ClearPool exit time:%d\n",time());
	};
};
hook("ScratchBuffer::TryLocklessAlloc")
{
	onenter{
		printf("ScratchBuffer::TryLocklessAlloc enter time:%d\n",time());
		//dumpstack("ScratchBuffer::TryLocklessAlloc");
		return 0;
	};
	onexit{
		printf("ScratchBuffer::TryLocklessAlloc exit time:%d\n",time());
	};
};
hook("ScratchBuffer::TrimMemory")
{
	onenter{
		printf("ScratchBuffer::TrimMemory enter time:%d\n",time());
		//dumpstack("ScratchBuffer::TrimMemory");
		return 0;
	};
	onexit{
		printf("ScratchBuffer::TrimMemory exit time:%d\n",time());
	};
};
hook("VKGpuProgram::Create")
{
	onenter{
		printf("VKGpuProgram::Create enter time:%d\n",time());
		//dumpstack("VKGpuProgram::Create");
		$a:int = ptrget(argv(0),8);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		$d:int = ptrget(argv(3),8);
		$name:string = format("%s",$d);
		if($name=="Hidden/VFX/5035155_gpu_zzy/System/Output Particle Quad"){
			assert(0);
		};
		return 0;
	};
	onexit{
		printf("VKGpuProgram::Create exit time:%d\n",time());
	};
};
hook("VKGpuProgram::Prepare")
{
	onenter{
		printf("VKGpuProgram::Prepare enter time:%d\n",time());
		//dumpstack("VKGpuProgram::Prepare");
		$a:int = ptrget(argv(0),8);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		$d:int = ptrget(argv(3),8);
		printf("this:%x\n", $a);
		$name:string = format("%s",$d);
		if($name=="Hidden/VFX/5035155_gpu_zzy/System/Output Particle Quad"){
			assert(0);
		};
		return 0;
	};
	onexit{
		printf("VKGpuProgram::Prepare exit time:%d\n",time());
	};
};
hook("GraphicsPipelineProvider::GetShaderModule")
{
	onenter{
		printf("GraphicsPipelineProvider::GetShaderModule enter time:%d\n",time());
		//dumpstack("VKGpuProgram::Create");
		$a:int = ptrget(argv(7),8);
		$b:int = ptrget(argv(7)+8,8);
		printf("GraphicsPipelineProvider::GetShaderModule key:%8.8x %8.8x\n",$a,$b);
		return 0;
	};
	onexit{
		$a:int = ptrget(argv(0),8);
		printf("GraphicsPipelineProvider::GetShaderModule ret:%x\n",$a);
		printf("GraphicsPipelineProvider::GetShaderModule exit time:%d\n",time());
	};
};
hook("GraphicsPipelineProvider::DeleteShaderModule")
{
	onenter{
		printf("GraphicsPipelineProvider::DeleteShaderModule enter time:%d\n",time());
		dumpstack("GraphicsPipelineProvider::DeleteShaderModule");
		$a:int = ptrget(argv(1),8);
		printf("GraphicsPipelineProvider::DeleteShaderModule obj:%x\n",$a);
		return 0;
	};
	onexit{
		printf("GraphicsPipelineProvider::DeleteShaderModule exit time:%d\n",time());
	};
};
hook("GraphicsPipelineProvider::GetPipelineCacheAndLayout")
{
	onenter{
		printf("GraphicsPipelineProvider::GetPipelineCacheAndLayout enter time:%d\n",time());
		//dumpstack("GraphicsPipelineProvider::GetPipelineCacheAndLayout");
		return 0;
	};
	onexit{
		$a:int = ptrget(argv(0),8);
		printf("GraphicsPipelineProvider::GetPipelineCacheAndLayout ret:%x\n",$a);
		printf("GraphicsPipelineProvider::GetPipelineCacheAndLayout exit time:%d\n",time());
	};
};
hook("GraphicsPipelineProvider::DeletePipelineCacheAndLayout")
{
	onenter{
		printf("GraphicsPipelineProvider::DeletePipelineCacheAndLayout enter time:%d\n",time());
		dumpstack("GraphicsPipelineProvider::DeletePipelineCacheAndLayout");
		$a:int = ptrget(argv(1),8);
		printf("GraphicsPipelineProvider::DeletePipelineCacheAndLayout obj:%x\n",$a);
		return 0;
	};
	onexit{
		printf("GraphicsPipelineProvider::DeletePipelineCacheAndLayout exit time:%d\n",time());
	};
};
hook("PipelineCreateInfo::Configure")
{
	onenter{
		printf("PipelineCreateInfo::Configure enter time:%d\n",time());
		//dumpstack("PipelineCreateInfo::Configure");
		return 0;
	};
	onexit{
		printf("PipelineCreateInfo::Configure exit time:%d\n",time());
	};
};
hook("CreateGraphicsPipeline")
{
	onenter{
		printf("CreateGraphicsPipeline enter time:%d\n",time());
		$a:int = ptrget(argv(0),8);
		$b:int = ptrget(argv(1),8);
		$c:int = ptrget(argv(2),8);
		printf("this:%x\n", $a);
		$name:string = format("%s",$c);
		if($name=="Hidden/VFX/5035155_gpu_zzy/System/Output Particle Quad"){
			assert(0);
		};
		//dumpstack("CreateGraphicsPipeline");
		return 0;
	};
	onexit{
		printf("CreateGraphicsPipeline exit time:%d\n",time());
	};
};